include/mlx/mlx_new_image.m:  newimg->next = mlx_ptr->img_list;
include/mlx/mlx_new_image.m:  newimg->width = width;
include/mlx/mlx_new_image.m:  newimg->height = height;
include/mlx/mlx_new_image.m:  newimg->vertexes[0] = 0.0;  newimg->vertexes[1] = 0.0;
include/mlx/mlx_new_image.m:  newimg->vertexes[2] = width;  newimg->vertexes[3] = 0.0;
include/mlx/mlx_new_image.m:  newimg->vertexes[4] = width;  newimg->vertexes[5] = -height;
include/mlx/mlx_new_image.m:  newimg->vertexes[6] = 0.0;  newimg->vertexes[7] = -height;
include/mlx/mlx_new_image.m:  newimg->buffer = malloc(UNIQ_BPP*width*height);
include/mlx/mlx_new_image.m:  bzero(newimg->buffer, UNIQ_BPP*width*height);
include/mlx/mlx_new_image.m:	       img->width, img->height, 0,           /* width, height, border */
include/mlx/mlx_new_image.m:	       img->buffer               /* pixels */
include/mlx/mlx_new_image.m:  glBufferData(GL_ARRAY_BUFFER, sizeof(img->vertexes), img->vertexes, GL_DYNAMIC_DRAW); // 4 points buff
include/mlx/mlx_new_image.m:  while (img && img->next)
include/mlx/mlx_new_image.m:      if (img->next == img_todel)
include/mlx/mlx_new_image.m:	img->next = img->next->next;
include/mlx/mlx_new_image.m:      img = img->next;
include/mlx/mlx_new_window.m:  glUniform2f(glsl.loc_image_size, img->width, -img->height);
include/mlx/mlx_new_window.m:  glUniform2f(glsl.loc_font_atlassize, img->width, img->height);
include/mlx/mlx_png.c:  ibuf = (unsigned char *)img->buffer;
include/mlx/mlx_png.c:  iline = img->width * UNIQ_BPP;
include/mlx/mlx_png.c:  ilen = img->width * img->height * UNIQ_BPP;
include/mlx/mlx_png.c:  blen = img->width * img->height * pi->bpp + img->height;
include/mlx/mlx_png.c:	img->buffer[ipos++] = 0xFF;
include/mlx/mlx_png.c:  if (!(buffer = malloc((long long)img->width*(long long)img->height*(long long)pi->bpp + img->height)))
include/mlx/mlx_png.c:	  if (b_pos + Z_CHUNK - z_strm.avail_out > img->width*img->height*pi->bpp+img->height)
include/mlx/mlx_png.c:  if (b_pos != img->width*img->height*pi->bpp+img->height)
include/mlx/mlx_png.c:      //      printf("pb : bpos %d vs expected %d\n", b_pos, img->width*img->height*pi->bpp+img->height);
include/mlx/mlx_png.c:      *width = img->width;
include/mlx/mlx_png.c:      *height = img->height;
include/mlx/mlx_xpm.c:      if (img->image->byte_order)
include/mlx/mlx_xpm.c:  //opp = img->bpp/8;
include/mlx/mlx_xpm.c:  data = img->buffer;
include/mlx/mlx_xpm.c:      //      data += img->size_line;
include/mlx/mlx_xpm.c:      data += img->width*4;
include/mlx/mlx_xpm.c:      img->gc = XCreateGC(xvar->display, clip_pix, 0, &xgcv);
include/mlx/mlx_xpm.c:      XPutImage(xvar->display, clip_pix, img->gc, clip_img,
include/mlx/mlx_xpm.c:      XFreeGC(xvar->display, img->gc);
include/mlx/mlx_xpm.c:      img->gc = XCreateGC(xvar->display, xvar->root, GCClipMask|GCFunction|
include/mlx/mlx_xpm.c:      *width = img->width;
include/mlx/mlx_xpm.c:      *height = img->height;
include/mlx/mlx_xpm.c:      *width = img->width;
include/mlx/mlx_xpm.c:      *height = img->height;
Binary file src/draw/.draw_utils_0.c.swp matches
src/draw/draw_utils_0.c:	buffer = (y * img->line_length + x * (img->bits_per_pixel / 8));
src/draw/draw_utils_0.c:	dst = img->addr + buffer;
